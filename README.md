<p align="center">
    <img src="https://developer.android.com/images/jetpack/compose/landing-preview-animation.gif" alt="Jetpack Compose">
    <br/>
برنامه‌سازی موبایل
  <br/>
  دانشکده‌ی مهندسی کامپیوتر
   <br/>
  دانشگاه صنعتی شریف
    <br/>
استاد: امید جعفری نژاد
    <br/>
نویسندگان: سید پارسا نشایی، محمدطه جهانی‌نژاد، مهدی ابوترابی
</p>

<div dir="rtl">
## آشنایی با Android Jetpack Compose
آشنایی با Android Jetpack Compose

تغییر در طراحی و معماری اپلیکیشن‌ها

سال‌هاست که برای نوشتن اپلیکیشن‌های موبایل، از یکی از معماری‌های طراحی قدیمی ولی کارراه‌انداز MVC، MVVM و موارد مشابه استفاده می‌کنیم. در غالب این معماری‌ها، codebase اصلی به بخش‌های گوناگونی تقسیم شده، ارتباط میان آن‌ها مشخص شده و سپس کدنویسی آغاز می‌شود. اکثر کدهایی که برای پلتفرم‌های موبایل نوشته می‌شود (مانند کدهایی که غالبا در برنامه‌نویسی اندروید به کمک Java و یا Kotlin انجام می‌دهیم و نیز کدهای iOS بر پایه‌ی UIKit)، اصطلاحا به شکل imperative هستند، یعنی در آن‌ها، دستورالعمل‌هایی نوشته می‌شود که مقادیر مشخص شده در ظاهر برنامه و نشان داده شده به کاربر را مستقیما تغییر دهند. در سال‌های اخیر، حرکتی از جانب توسعه‌دهندگان موبایل از سمت برنامه‌نویسی imperative به برنامه‌نویسی declarative آغاز شده است؛ در برنامه‌نویسی declarative، نحوه‌ی رفتار برنامه در پاسخ به ورودی‌ها را مشخص می‌کنیم، بدون آن‌که به صورت صریح، کدهایی برای تغییر حالات و state های برنامه بنویسیم. به عبارت دیگر، در برنامه‌نویسی imperative به سیستم می‌گوییم که چه کارهایی را به ترتیب انجام دهد تا به خروجی دل‌خواه‌مان برسیم، ولی در برنامه‌نویسی declarative به سیستم می‌گوییم که در انتظار انجام شدن چه کاری و تحت چه شرایطی هستیم، و جزئیات آن عمل بیان نمی‌شود.
به عنوان یک مثال، فرض کنید در حال نوشتن اپلیکیشن Twitter هستید و می‌خواهید هرگاه طول یک توییت بیش از ۲۸۰ کاراکتر شد، دکمه‌ی Send غیر فعال شود. دو راه برای پیاده‌سازی این امکان وجود دارد:
روش imperative: یک تابع را به عنوان یک listener برای تغییرات text box توییت نسبت دهیم، سپس در تابع هر بار متن داخل text box را خوانده، تعداد کاراکترهای آن را بشمریم و اگر این تعداد از ۲۸۰ بیش‌تر بود، ویژگی enabled دکمه‌ی Send را false وگرنه true کنیم.
روش declarative: ویژگی enabled دکمه‌ی Send را به شرط «تعداد کاراکترهای text box بیش‌تر از ۱۸۰ بودن» مقید کنیم که در نتیجه‌ی آن، سیستم با هر تغییری در تعداد کاراکترهای text box، شرط ویژگی enabled دکمه‌ی Send را بازمحاسبه (recalculate) می‌کند.
هر دو روش فوق، دقیقا یک کار را انجام می‌دهند، اما در روش دوم، ما تنها برای سیستم «توصیف» کرده‌ایم که ویژگی enabled دکمه با شرط «تعداد کاراکترهای text box بیش‌تر از ۱۸۰ بودن»، در ارتباط است؛ در روش دوم از هیچ‌گونه انتساب مستقیمی به ویژگی enabled استفاده نشده است. از مزایای declarative کد زدن، آن است که با توصیف کلیات و نحوه‌ی کارکرد سیستم برای کامپیوتر و اجتناب از توصیف ریز به ریز جزئیات، احتمال وجود خطا در سیستم کاهش می‌یابد. این کاهش احتمال خطا، در سیستم‌های پیچیده‌تر از مثال ساده‌ی فوق، مشهودتر است؛ در سیستم‌هایی که در آن‌ها داده از مکان‌های مختلفی هم‌چون پایگاه داده، cache محلی، حافظه‌ی خارجی، شبکه و... در اختیار اپلیکیشن قرار می‌گیرد، برای اطمینان از صحت کارکرد کد imperative باید تمامی ترتیب‌های مختلف اعمال ورودی‌ها و دریافت داده‌ها در نظر گرفته شود، در حالی‌که به کمک یک کد declarative می‌توان منابع ورود داده را مشخص کرد و از سیستم خواست که خود اقدام به مدیریت آن‌ها نماید.
از توضیحات فوق، می‌توان نتیجه گرفت که در یک کد از نوع declarative، باید دو ویژگی زیر مورد توجه قرار گیرد:
وجود ساز و کاری برای اعلان تغییرات یک نقطه‌ی کد به نقاط دیگر (به عنوان مثال، اعلام رسیدن داده‌ی جدید از شبکه به بخشی از اپلیکیشن که وظیفه‌ی مدیریت داده‌ها و به روز رسانی view ها را بر عهده دارد) که به کمک روش‌هایی هم‌چون الگوی Subscriber قابل پیاده‌سازی است؛
و مجهز بودن اپلیکیشن به کنترل‌هایی در View های رابط کاربری خود که با این سیستم هماهنگ بوده و پس از اعلان شدن تغییرات در state ها و حالت‌های متغیرها در کد، خود را به‌روزرسانی کنند.
تیم توسعه‌دهندگان سیستم‌عامل اندروید، با توجه به دو ویژگی فوق، کتاب‌خانه‌ی Jetpack Compose را که بخشی از سری کتاب‌خانه‌های Jetpack است، عرضه کرده است. این کتاب‌خانه که برای طراحی UI اپلیکیشن‌های اندرویدی، به شکل declarative، جای‌گزین طراحی XML و ارتباط آن با کد می‌شود، دارای سه ویژگی اصلی زیر است:
قابلیت طراحی UI به شکل declarative: در این کتاب‌خانه، به جای آن‌که View ها را در کد به کمک findViewById یافته و سپس ویژگی‌های آن‌ها را تغییر دهیم، قطعه کدی که View ی ما را می‌سازد را با پارامترهای جدید و دل‌خواه، مجددا اجرا می‌کنیم تا خود سیستم در هر مرحله تغییر داده‌های اپلیکیشن، اقدام به به‌روزرسانی بخش‌های مرتبط در View ها نماید.
طراحی UI به شکل ماژولار (composable): در شیوه‌ای از طراحی که با آن از قبل در برنامه‌نویسی اندروید آشناییم، تعدادی Activity و یا Fragment تعریف می‌کنیم که صفحات اصلی برنامه‌ی ما را تشکیل می‌دهند و سپس component های جزئی‌تر را درون آن‌ها تعریف می‌کنیم. در شیوه‌ای از طراحی که Jetpack Compose (و نیز بسیاری از کتاب‌خانه‌های طراحی declarative UI دیگر، هم‌چون SwiftUI) از آن استفاده می‌کنند، تمامی UI از دانه‌ها و بلاک‌های ریزی تشکیل شده که به یک‌دیگر متصل شده و بلاک‌های بزرگ‌تری را به وجود می‌آورند و لزومی نیست هر صفحه‌ی اپلیکیشن به صورت جدا از بقیه طراحی شود؛ این ویژگی که به composability مشهور است، سبب افزایش استفاده‌ی مجدد از کدهای نوشته شده (code reuse) و نیز خوانایی بیش‌تر کد می‌شود.

این کتاب‌خانه‌ی UI مزایای دیگری هم‌چون هماهنگی اتوماتیک و اصطلاحا out of the box با طراحی متریال (Material Design) را نیز داراست.

کتاب‌خانه‌ی Jetpack Compose از زبان Kotlin استفاده می‌کند.

نوشتن یک اپلیکیشن با Jetpack Compose

هدف از این مقاله، آشنایی با نحوه‌ی ساخت یک اپلیکیشن نمونه از صفر تا صد - و به واسطه‌ی آن، آشنایی با امکانات متعدد Jetpack Compose - است. اپلیکیشنی که به این منظور انتخاب می‌کنیم، یک اپلیکیشن نمونه است که لیستی از رمزارزها را با نام، عکس و قیمت نشان دهد.

این اپلیکیشن نمونه، به گونه‌ای انتخاب شده است که المان‌های مشترک بسیاری از اپ‌ها (هم‌چون App Bar، نمایش عکس و حالات مختلف آن و نیز لیست‌ها) را در خود جای داده باشد.

ساخت پروژه

توجه کنید که در زمان نگارش این مقاله، کتاب‌خانه‌ی Jetpack Compose هنوز در فاز beta قرار دارد و در نتیجه، لازم است از نسخه‌ی Canary (Arctic Fox) محیط Android Studio برای توسعه‌ی اپ به کمک Jetpack Compose استفاده کنید.

۱. از صفحه‌ی اولیه‌ی محیط Android Studio گزینه‌ی New Project را انتخاب کنید:

۲. در صفحه‌ی باز شده، گزینه‌ی Empty Compose Activity را انتخاب کنید:


۳. اطلاعات مربوط به پروژه را وارد کرده و Finish را بزنید. از اتصال ابزار تغییر آی‌پی خود، اطمینان حاصل کنید. توجه کنید که همان‌طور که گفته شد، در این صفحه نمی‌توان زبان پیشنهادی را از Kotlin به Java تغییر داد.
توجه: در هنگام اولین بار ساخت پروژه، ممکن است نیاز باشد منابع و ریسورس‌هایی از سرورهای گوگل دریافت شود که مدت زمان قابل توجهی به طول می‌انجامد:

پس از اتمام Gradle Build و build کامل پروژه، صفحه‌ی زیر مشاهده می‌شود که در آن، نمای سمت راست، پیش‌نمایشی از view ی کنونی است که کد آن در سمت چپ باز است:

در صورت اجرا کردن برنامه‌ی پیش‌فرض در امولیتور اندروید، با این نما مواجه می‌شویم:

حال با یک‌دیگر بررسی می‌کنیم که چگونه این view ساخته شده است؟

همان‌طور که گفته شد، در Jetpack Compose، نماها به صورت طبقه‌بندی و ساختار درختی ساخته می‌شوند. در کلاس MainActivity یک متد onCreate وجود دارد که وظیفه‌ی آن، (پس از صدا زدن onCreate کلاس پدر) صدا زدن یک متد بسیار مهم و حیاتی در کارکرد این کتاب‌خانه به اسم setContent است که به عنوان پارامتر ورودی، view از جنس @Composable می‌گیرد و این view روی صفحه render می‌شود.

ممکن است بپرسید که ما تنها امکان برگرداندن یک view در setContent را داریم، پس چگونه می‌توانیم layout هایی شامل چندین view بسازیم؟

پاسخ این سوال در composition نماهای برنامه نهفته است؛ همان‌گونه که در سیستم سنتی برنامه‌سازی اندروید علاوه بر تعدادی View، تعدادی ViewGroup داریم که وظیفه‌ی آن‌ها نگه‌داری تعدادی View است، در Jetpack Compose نیز می‌توان view هایی در setContent برگرداند که خود مجموعه‌ای از view ها باشند که یک layout مشترک به آن‌ها داده شده است. هر یک از این view ها خود می‌توانند یک تابع باشند که view ی مد نظر را بر اساس view های پایه‌ای دیگر بسازد و یک Composable برگرداند، تا بتوانیم view ها را درون یک‌دیگر قرار دهیم یا compose کنیم.

حال با یک‌دیگر بررسی می‌کنیم که درون تابع setContent ما به طور پیش‌فرض چه چیزی قرار گرفته است:

بالاترین آبجکتی که مستقیما return می‌شود، [YourProgramName]Theme است که وظیفه‌ی آن، دادن الگوهای کلی (هم‌چون فونت و رنگ‌ها در سراسر اپ) است؛ در حقیقت، می‌توان این‌گونه به این تابع نگاه کرد که این تابع، View داخلی خود را گرفته، اصلاحات رنگ و فونت را روی آن اعمال (modify and apply) کرده و نتیجه را برمی‌گرداند؛ البته، از نقطه نظر فنی، شرایط کمی متفاوت است، اما این شهود به درک چگونگی کارکرد composition در این کتاب‌خانه کمک شایانی کرده و سبب می‌شود که بهتر و به راحتی بتوانیم ایده‌های خود را در قالب view هایی که این‌چنین در یک‌دیگر compose می‌شوند، پیاده کنیم.

آبجکت بعدی که مقدار خروجی تابع آن به ورودی [YourProgramName]Theme می‌رود، تابع Surface است. اگر با ایده‌ی Surface ها از طراحی متریال (Material Design) آشنا باشید، به خوبی با تابع Surface و معنای پارامتر آن در مثال پیش‌فرض (که رنگ سرفیس که در حقیقت بک‌گراند صفحه خواهد بود را معین می‌کند)، خو خواهید گرفت.

آبجکت بعدی که مقدار خروجی تابع آن به ورودی Surface می‌رود، تابع Greeting است. اما تابع Greeting چیست؟

ساخت توابع برای view های تودرتو

احتمالا خواننده حدس زده است که تابع Greeting - با توجه به اسمش - از توابعی نیست که در کتاب‌خانه موجود باشد و تابعی است که خود آن را نوشته ایم. همان‌طور که در فایل MainActivity.kt و در خط ۲۷ به بعد مشاهده می‌شود، تعریف تابع به شکل زیر است:

```
@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
```
نکات زیر در خصوص تابع قابل مشاهده اند:
تابع دارای انوتیشن @Composable است، به این معنا که می‌تواند مانند توابعی هم‌چون Surface، در طبقه‌بندی view ها ظاهر شود.
تابع یک ورودی name دارد. این ورودی نشان می‌دهد که تابع Greeting همواره یک viewی ثابت را نشان نمی‌دهد و کمیت و کیفیت view ی نشان داده شده، بسته به حالت برنامه دارد.
نکته‌ی مهم: توجه کنید که در این تابع، name مانند اندرویدنویسی سنتی، یک property از یک آبجکت View نیست؛ بلکه قرار است در نهایت با هر بار تغییر در پارامتر name، این تابع بازفراخوانی شده و تغییرات لازم در view های برنامه صورت پذیرد. در این کتاب‌خانه، هنگام تغییر state ها و حالت‌های برنامه، به جای آن‌که کدی بنویسیم که یک  یا چند property را تغییر دهد یا یک یا چند متد را روی یک view فراخوانی کند، متدی می‌نویسیم که گویی دارد آن view را مجددا می‌سازد.
مقدار برگشتی این تابع (شاید بهتر است بگوییم مقدار Compose شده، زیرا در اصل تابع از نظر قواعد دستوری کاتلین، نوع بازگشتی ندارد و منظور از برگشت در این مقاله، به کمک annotation ذکر شده در بالای تابع است)، یک Text است.
توضیح Text: ویوی Text از view های کتاب‌خانه است و کارکردی مشابه TextView دارد. پارامتر ورودی آن، متنی است که باید در label نمایش داده شود. از این نظر، کارکرد Text بسیار مشابه استراکت Text در SwiftUI است.

همان طور که مشخص است، به سادگی و با در هم قرار دادن view ها، layout مدنظرمان ساخته شده است. توجه کنید که تمام layout را در setContent قرار ندادیم و بخشی از آن را به صورت یک تابع جدا کردیم تا کد، خوانایی خود را حفظ کند و pyramid of doom ایجاد نشود.

بخش Preview

بخش دیگری از فایل تحت عنوان Preview باقی مانده که لازم است به آن نیز اشاره کنیم:

```
@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    ComposeCryptoTheme {
        Greeting("Android")
    }
}
```

از امکانات خوب اندروید استودیو در رفتار با این کتاب‌خانه، نشان دادن یک Preview از ویوی کنونی در پنل راست، بدون نیاز به اجرای امولیتور اندروید است.

در تکه کد فوق، موارد زیر قابل رویت‌اند:
انوتیشن @Preview که مشخص می‌کند با یک تابع که وظیفه‌ی آن، برگرداندن (compose کردن) یک view برای نمایش آن در اندروید استودیو است، سر و کار داریم
پارامتر showBackground که مشخص می‌کند آیا تنها آبجکت قید شده در این بخش به خودی خود نشان داده شود یا برای واقع‌بینانه‌تر شدن، یک بک‌گراند نیز برای آن در نظر گرفته شود
انوتیشن @Composable که قبلا آن را شرح داده‌ایم
آبجکت / تابع ComposeCryptoTheme که قبلا آن را شرح داده‌ایم
و در نهایت تابع Greeting با یک پارامتر دل‌خواه (برای این‌که چگونگی کارکرد view را در پنل راست تست کنیم) صدا زده شده است.

توابع layout در Compose

اپلیکیشن نمونه، در عمل تنها یک آبجکت را روی صفحه نشان می‌دهد که در چند wrapper پوشانده شده است؛ در حالی‌که از مباحثی چون LinearLayout در اندروید می‌دانیم که وجود چند layout در صفحه و نیز چینش آن‌ها نسبت به یک‌دیگر، بسیار حائز اهمیت است. 

اگر در تابع setContent مان، چند Text قرار دهیم، همگی روی هم می‌افتند:
```
Text("Hello, World!", style = TextStyle(color = Color.Red))
Text("Hello, Second World!", style = TextStyle(color = Color.Red))
Text("Hello, Third World!", style = TextStyle(color = Color.Red))
```



برای رعایت درست ترتیب المان‌ها نسبت به هم،
می‌توانیم از Column برای چینش عمودی چند آیتم (مشابه VStack در SwiftUI) استفاده کنیم:
```


```

و یا از Row برای چینش افقی چند آیتم استفاده کنیم (مشابه HStack در SwiftUI):

```


```

توجه مهم: هیچ‌گاه یک تابع Composable را از درون تابعی که Composable یا setContent نیست، فراخوانی نکنید، زیرا سبب کرش کردن برنامه می‌شود.

حال که با برخی از اصول مقدماتی کار با این کتاب‌خانه آشنا شدیم، به سراغ پیاده‌سازی پروژه‌ی نمونه‌ای که گفته شد، می‌رویم تا اصول فوق را تمرین کرده و نیز با تعداد زیادی از امکانات دیگر این کتاب‌خانه آشنا شویم.

پیاده‌سازی برنامه‌ی Crypto (مشاهده‌ی نام، عکس، مشخصات و قیمت رمزارزها)

ابتدا یک فایل جدید در پکیجی که MainActivity.kt در آن قرار دارد به اسم Crypto.kt ایجاد می‌کنیم تا در آن، کلاس Crypto و نیز چند crypto ی نمونه را قرار دهیم.

ابتدا به این فایل، دیتاکلاس زیر را اضافه می‌کنیم:
```
data class Crypto(
    @DrawableRes
    val imageResource: Int,
    val name: String,
    val price: Double
)
```
کلاس فوق، شامل فیلدهای عکس، نام، قیمت کنونی رمزارز است.

سپس یک آرایه برای نگه‌داری تمام crypto های سیستم تعریف می‌کنیم (در یک اپلیکیشن واقع‌بینانه، این آرایه از سرور گرفته می‌شود؛ اما برای نشان دادن کارکرد Compose از جزئیات مربوط به اتصال به اینترنت که از اندروید می‌‌دانیم، صرف نظر می‌کنیم):

```
val allCryptos = arrayOf(
    Crypto(R.drawable.bitcoin, "Bitcoin", 1000.5),
    Crypto(R.drawable.ethereum, "Ethereum", 5000.5),
    Crypto(R.drawable.dogecoin, "Dogecoin", 200.0),
    Crypto(R.drawable.monero, "Monero", 50.7)
)
```
توجه شود که لازم است drawable های دل‌خواه خودتان برای عمل کردن به عنوان عکس‌های رمزارزها، به پوشه‌ی drawable اضافه شوند.

حال پس از آن‌که مدل تکمیل شد، لازم است UI و کد کنترل آن، طراحی شوند. قرار است در view ی نخست‌مان، یک لیست از رمزارزها داشته باشیم که اطلاعات‌شان را نشان دهد.

از اندرویدنویسی (و یا iOS نویسی)، می‌دانیم لازمه‌ی داشتن هر لیستی، آن است که طراحی هر آیتم لیست را ابتدا داشته باشیم؛ پس از طراحی هر آیتم لیست، کار خود را آغاز می‌کنیم.

ابتدا یک فایل به نام CryptoListItem.kt می‌سازیم و کد زیر را در آن می‌نویسیم:
```
@Composable
fun CryptoListItem(crypto: Crypto) {
    Text(text = crypto.name)
}

@Preview(showBackground = true)
@Composable
fun DefaultCryptoListItem() {
    CryptoListItem(allCryptos[0])
}
```
تابعی که به عنوان هر آیتم لیست تعریف می‌شود، باید یک پارامتر از نوع مدلی داشته باشد که قرار است لیست، آرایه‌ی از آن مدل را به کاربر نشان دهد (در این‌جا Crypto). فعلا، تابع ما تنها یک label با اسم رمزارز می‌سازد.

هم‌چنین، Preview ی طراحی را نیز نوشته‌ایم که نمونه‌ی آیتم لیست را برای آیتم نخست داده‌های تست‌مان، نشان می‌دهد.

نکته‌ی مهم: هر از چند گاهی، ممکن است Preview خود به خود آپدیت نشود؛ در این شرایط، لازم است دکمه‌ی Build and Refresh در بالای بخش Design (پنل سمت راست در مد Split) را بزنید.

یک پرسش متداول: ممکن است برای خواننده این سوال پیش بیاید که توابع غالبا به شکل camelCase نوشته می‌شدند، پس چرا توابع Composable را به شکل PascalCase می‌نویسیم؟

پاسخ: در اکثر فریم‌ورک‌های طراحی declarative رابط کاربری، رسم است که توابع Composable - چه واقعا تابع باشند (مثل کتاب‌خانه‌ی Compose) و چه کلاس باشند - به شکل PascalCase نوشته شوند. این قاعده، هم در Jetpack Compose، هم در SwiftUI و هم در Flutter برقرار است.

طراحی داخلی لیست آیتم

حال، می‌خواهیم طراحی داخلی هر آیتم لیست را انجام دهیم. کد زیر را جای‌گزین کد درون تابع CryptoListItem کنید:
```
Column(modifier = Modifier.fillMaxWidth()) {
    Image(painter = painterResource(crypto.imageResource),
        "Image of ${crypto.name}",
        contentScale = ContentScale.Crop,
        modifier = Modifier.fillMaxWidth().height(200.dp))
    Text(text = crypto.name, style = MaterialTheme.typography.h5)
    Text(text = "Price: ${crypto.price}", style = MaterialTheme.typography.h6)
}
```
حال به توضیح کد نوشته شده می‌پردازیم:

ابتدا برای طراحی ستونی، یک Column قرار داده‌ایم. یک پارامتر تازه برای این تابع در نظر گرفته شده است: modifier. متدهای درون Modifier به ما اجازه می‌دهند تا تنظیماتی را روی کلیت Column (و نه آیتم‌های درون آن) اعمال کنیم؛ به عنوان مثال:
ارتفاع و عرض شی را تنظیم کنیم
میزان padding و offset را تنظیم کنیم
بک‌گراند را تنظیم کنیم
به شی border بدهیم
متدهای callback در صورت رخدادهایی هم‌چون onClick را به شی نسبت دهیم
امکان draggable بودن یا نبودن شی و نیز چگونگی رفتار آن هنگام drag را مشخص کنیم
در مثال ما، می‌خواهیم که این ستون، از محتوای درونش به اندازه‌ی 12 dp فاصله داشته باشد که در Compose به کمک Modifier.padding(12.dp) پیاده‌سازی می‌شود.

سپس، درون Column، ابتدا یک Image قرار داده شده است که شامل پارامترهای زیر است:
پارامتر painter که به کمک تابع painterResource، از drawable ریسورس عکس مربوطه را گرفته و به آن داده‌ایم تا روی صفحه نمایش داده شود
پارامتر contentDescription که توضیح متنی از عکس (مشابه alt در دنیای HTML) را ارائه می‌دهد؛ این توضیح هنگام استفاده از ابزارهای کمکی Accessibility به کاربر ارائه می‌شود.
توجه: به توصیه‌ی documentation کتاب‌خانه‌ی Jetpack Compose، اگر عکس تنها کاربرد تزئینی دارد و معنای به‌خصوصی در آن نیست، می‌توانید فکر کردن و طراحی یک رشته‌ی مناسب برای این پارامتر را نادیده بگیرید.
پارامتر contentScale که انتخاب میان انواع جاگذاری عکس را در اختیار برنامه‌نویس قرار می‌دهد؛ این انواع، مشابه تمامی پلتفرم‌های دیگر هستند و به شرح زیرند:
نوع Crop کردن
نوع FillBounds کردن
نوع FillHeight کردن
نوع FillWidth کردن
نوع Fill کردن
نوع Inside کردن
هیچ‌کدام (None)
پارامتر modifier: در این‌جا عرض تصویر را به اندازه‌ی ممکن بزرگ می‌کنیم (fillMaxWidth که مشابه match_parent برای پارامتر width در اندروید سنتی است)، اما بر خلاف Column که ارتفاعش اتوماتیک بر اساس جمع ارتفاع فرزندان تعیین می‌شد، این‌جا برای نمایش درست عکس نیاز داریم که ارتفاع مناسبی برای عکس مشخص کنیم. این کار با متد .height(200.dp) انجام شده است که ارتفاع عکس را برابر 200 dp تعیین می‌کند.

پس از Image (و چون در یک Column هستیم، یعنی در زیر Image)، یک Text داریم که محتوای آن، نام رمزارز است و سپس به کمک پارامتر style و دادن  MaterialTheme.typography.h5، به آن فونت هدینگ ۵ داده‌ایم (مشابه heading ها در HTML). همان‌طور که مشاهده می‌شود، پشتیبانی فراوان و مشخصی از طراحی متریال در این کتاب‌خانه، وجود دارد.
پس از (و چون در یک Column هستیم، یعنی در زیر) Text قبلی، یک Text دیگر ولی این بار با محتوای قیمت رمزارز و نیز فونت h6 (یک درجه ریزتر از عنوان رمزارز) چاپ می‌کنیم.

اگر بخواهیم کمی به‌اصطلاح Material ای بودن لیست‌آیتم‌مان بیش‌تر شود، می‌توانیم کل کد را در یک بلاک Surface به شرح زیر قرار دهیم (که توضیح آن قبلا داده شده و معنای اصطلاحات به کار رفته نیز در اصول طراحی متریال موجود است):
```
Surface(shape = RoundedCornerShape(10.dp), elevation = 10.dp) {
	// the rest of the code
}
```

این بلاک سبب می‌شود تا گوشه‌های لیست‌آیتم‌مان به مقدار مشخص شده، گرد شوند.

طراحی لیست

حال که لیست‌آیتم‌مان آماده است، یک فایل برای طراحی لیست به نام CryptoList.kt می‌سازیم. در این فایل، متد زیر را درج می‌کنیم:

```
@Composable
fun CryptoList(cryptos: List<Crypto>) {
    LazyColumn {
        items(allCryptos.size) { index ->
            CryptoListItem(crypto = allCryptos[index])
        }
    }
}
```

حال به توضیح متد فوق می‌پردازیم.

مشخص است که یک لیست نیز نوع خاصی از Column است، با این تفاوت که تعداد اجزای آن در زمان اجرا مشخص نیست و نیز قابلیت اسکرول دارد، به گونه‌ای که داده‌هایی که در صفحه مشخص نیستند، تا زمانی که به روی آن‌ها اسکرول نکرده‌ایم، لود نمی‌شوند. این ویژگی سبب افزایش performance اپلیکیشن می‌شود. برای چنین کاربردهایی از LazyColumn استفاده می‌کنیم که به نوعی می‌توان آن را همتای RecyclerView در Compose دانست.

درون LazyColumn از یک تابع خاص به نام items استفاده می‌کنیم که view ی compose شده درون خود را به تعداد count بار می‌سازد، که در آن count پارامتر ورودی نخست تابع است. در هر بار compose یکی از view ها، یک index نیز به درون بلاک پارامتر این تابع، پاس داده می‌شود تا کد بداند که کدام یک از view ها را باید compose کند.

در نهایت، به ازای هر بار فراخوانی بلاک مربوط به تابع items، یک لیست‌آیتم را برمی‌گردانیم که ورودی آن، رمزارز index ام است.

همان طور که مشاهده می‌کنید، کل کد مربوط به لیست، به سادگی و بدون نیاز به کار با API های بعضا دشوار مربوط به RecyclerView، نوشته شده است.

در نهایت، کافی است به جای تابع Greeting در تابع setContent و نیز در Preview فایل MainActivity.kt، بنویسیم CryptoList() و سپس برنامه را اجرا کنیم.

نکته‌ی کاربردی: نیازی به اجرای برنامه در امولیتور برای تست مواردی هم‌چون اسکرول‌پذیری نیز نیست؛ می‌توانیم با انتخاب گزینه‌ی  در پنل Preview، در همان پنل فرآیند تست را به واسطه‌ی ورود به Interactive Mode انجام داده و هر زمان خواستیم، با کلیک روی دکمه‌ای که بعد از آغاز Interactive Mode نمایش داده می‌شود، از Interactive Mode خارج شویم.

توجه: همان‌طور که احتمالا مشاهده کرده‌اید، فاصله‌ی میان آیتم‌های لیست رمزارزها، به خوبی تنظیم نشده و آیتم‌های رمزارزها از یک‌دیگر متمایز نشده‌اند؛ برای بهتر شدن تمایز، کافی است به کل Surface هر لیست آیتم، یک padding بدهیم، یعنی خط صدا زدن تابع Surface در فایل CryptoListItem.kt را به شکل زیر تغییر دهیم:
```
Surface(shape = RoundedCornerShape(10.dp), elevation = 10.dp, modifier = Modifier.padding(15.dp)) {
```
حال، پس از اجرا، نتیجه‌ی حاصل، بسیار بهتر (و نیز Material ای تر!) خواهد بود؛ اکنون، هر آیتم در لیست، شبیه یک کارت شده است:

طراحی App Bar برای اپلیکیشن


یکی از گام‌های مهم در راستای حرفه‌ای‌تر کردن پروژه که اتفاقا از امور پرکاربرد در اپ نویسی نیز است، افزودن یک App Bar به برنامه است که امکان navigation را در برنامه فراهم کند. می‌دانیم App Bar باید در view ی اولیه‌ی برنامه، بالای لیست‌مان ظاهر شود، پس به یک Column نیاز داریم.

کد زیر را جای‌گزین هر آن‌چه در setContent و نیز در DefaultPreview در فایل MainActivity.kt تاکنون نوشته‌اید، نمایید:
```
ComposeCryptoTheme {
    Surface(color = MaterialTheme.colors.background) {
        Column(modifier = Modifier.fillMaxSize()) {
            TopAppBar(title = {
                Text("CryptoApp")
            })
            CryptoList()
        }
    }
}
```

به توضیح بخش‌های جدید کد فوق می‌پردازیم:
پارامتر ورودی modifier المان Column اضافه شده را Modifier.fillMaxSize() تعیین کرده‌ایم، زیرا باید این Column به وضوح، ماکسیمم فضای ممکن را پر کند.
یک المان TopAppBar قرار داده شده که وظیفه‌ی آن، تعیین مشخصات و افزودن App Bar به اپلیکیشن است.
این المان یک پارامتر title با یک نکته‌ی بسیار مهم دارد: این پارامتر از نوع String نیست، بلکه خود یک Composable است. Composable بودن پارامتر title به ما امکان آزادی بیش‌تر (در انتخاب مورد و یا مواردی که می‌توان به جای عنوان در App Bar قرار داد) را می‌دهد.

پس از اجرای اپ، می‌بینیم که App Bar به درستی اضافه شده است:


برخی مباحث مهم دیگر در Jetpack Compose

آشنایی با remember و state ها

مفهوم remember، یکی از خدمات ارائه شده توسط Compose است که توانایی مانیتور و ردیابی کردن state ها و حالات برنامه را دارد. این خدمت، سبب می‌شود تا بتوانیم بر اساس تغییر در state ای از برنامه که مشخص می‌کند در کدام view هستیم، قادر به تغییر UI به شکل اتوماتیک و مطابق با state متغیرهای کد باشیم. اما State چیست؟

به زبان ساده، State هر مقداری در اپ است که بتواند به مرور زمان (و در اثر اکشن‌های کاربر و یا شرایط محیطی)، تغییر کند. به عنوان مثال، مقدار ذخیره شده در یک پایگاه داده، عدد خوانده شده از یک سنسور دما یا سرعت یا متن نوشته شده در یک جعبه‌ی متن که کاربر در حال تایپ در آن هست، همگی state هستند.

نکته‌ی مهم در خصوص state آن است که تمامی برنامه‌ها، مکانیسم‌هایی برای نمایش state های اپلیکیشن به کاربران دارند، مثلا (مثال‌های زیر، شهودی هستند و لزوما از remember در آن‌ها استفاده نمی‌شود؛ مثلا ممکن است در برخی از آن‌ها از Service ها استفاده شود):
برنامه‌ای هرگاه که اینترنت قطع شد (به عبارت دیگر، state مربوط به وصل بودن اینترنت، مقدار false پیدا کرد)، یک Toast نشان می‌دهد
دکمه‌ای، هرگاه روی آن tap شود، یک انیمیشن از خود بروز می‌دهد (مشابه دکمه‌های Material)
یک اپلیکیشن بک‌آپ تصاویر گالری موبایل، هرگاه گوشی به شارژ زده شود و کاربر درون اپ باشد، بک‌آپ را آغاز و به محض جدا شدن گوشی از شارژر، بک‌آپ را متوقف می‌کند تا مصرف باتری به شکل بی‌رویه‌ای بالا نباشد

حال که با مفهوم پایه‌ای state آشنا شدیم، مثالی را با یک‌دیگر بررسی می‌کنیم. فرض کنید قرار است یک Text و یک TextField قابل تایپ داشته باشیم که هرگاه اسمی درون TextField تایپ شود، در Text متنی بنویسیم و به کاربر سلام کنیم؛ مثلا اگر کاربر نوشت Parsa، متن TextField به Hi Parsa تغییر یابد. برای انجام این کار در Compose از کد زیر استفاده می‌کنیم که آن را توضیح خواهیم داد:
```
Column {
    var name by remember { mutableStateOf("") }
    if (name.isNotEmpty()) {
        Text(text = "Hi $name")
    }
    OutlinedTextField(
        value = name,
        onValueChange = { value -> name = value }
    )
}

```

توجه: اگر کد فوق موجب خطای syntax شد، import های زیر را دستی به بالای فایل بیفزایید:
```
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
```

حال، کد فوق را توضیح می‌دهیم:
از Column برای نگه‌داشتن هم Text و هم TextField در بالا و پایین یک‌دیگر استفاده شده است.
متغیر name یک متغیر state است، زیرا به کمک remember تعریف شده است. دلیل state تعریف کردن name مشخص است، زیرا تغییر در آن باید سبب تغییر در نمایش Text شود. مقدار پیش‌فرض name به عنوان پارامتر mutableStateOf در همان خط داده شده است.
سپس، کد چک می‌کند که اگر name خالی نبود، Text شامل متن سلام کردن به name را نشان دهد. هر تغییری در state (یعنی name)، سبب ارزیابی مجدد این شرط if شده و شرایط نشان داده شدن یا نشدن Text مجددا بررسی می‌شود. سپس در بدنه‌ی if، می‌توانیم Text مان را که visible و نمایان بودنش، مشروط به خالی نبودن مقدار درون TextField است را قرار دهیم.
در نهایت نیز یک OutlinedTextField تعریف می‌کنیم، مقدار آن در هر لحظه را برابر name مشخص کرده و نیز معین می‌کنیم که در صورت تغییر در محتوای TextField، متغیر name نیز به‌روزرسانی شود.

بر اساس آن‌چه توضیح داده شد، به‌روزرسانی name سبب ارزیابی مجدد شرط‌ها و به‌روزشدن UI با مقادیر درست می‌شود، و این در حالی است که هیچ ارتباط مستقیمی میان TextField و Text وجود ندارد. وظیفه‌ی برقراری ارتباطات پیچیده میان اشیا - که در صورت وجود n شی، ممکن است تا  ارتباط به وجود آید - به عهده‌ی کتاب‌خانه است و به واسطه‌ی به‌روزکردن متغیرهای state (تعریف شده با remember) انجام می‌شود.

نکته‌ی مهم: تمامی state هایی که به شکل فوق تعریف می‌شوند، در صورت تغییر configuration اپ (مثلا، rotate شدن صفحه)، محتوای خود را از دست داده و به محتوای پیش‌فرض بر می‌گردند (رفتاری مشابه اندروید سنتی)؛ جهت حفظ مقدار state ها در تغییر configuration، می‌توانید به جای کلمه‌ی remember در تعریف این state ها، از کلمه‌ی  rememberSaveable استفاده کنید.

افزودن انیمیشن به اپلیکیشن‌های Compose

مشابه SwiftUI، کتاب‌خانه‌ی Compose نیز استفاده از انیمیشن‌ها در حد مبتدی را بسیار آسان کرده است. به مثال زیر توجه کنید:
```
val backgroundColor = if (tabPage == TabPage.Home) Purple100 else Green300
```

در قطعه‌کد فوق، tabPage یک متغیر state است. این کد، رنگ بک‌گراند صفحه را متناسب با این‌که در کدام tab هستیم، تنظیم می‌کند. با توجه به state بودن tabPage، می‌دانیم هر تغییری در tab انتخاب شده (مثلا tap کردن روی یک tab جدید)، سبب تغییر مقدار این متغیر و در نتیجه، ارزیابی دوباره‌ی متغیر backgroundColor می‌شود (val بودن backgroundColor، منافاتی با ارزیابی دوباره‌ی مقدار آن توسط Compose ندارد و لازم نبود حتما توسط var که متغیر است و نه ثابت، تعریف شود؛ این‌جا val را می‌توان به این معنا تعبیر کرد که مقدار backgroundColor به طور مشخص و deterministic بر اساس یک state variable تعیین می‌شود.

قطعه‌کد فوق، مشکلی ندارد؛ اما در صورت تعویض tab، کاربر به ناگهان یک تغییر فوری در رنگ بک‌گراند صفحه خواهد دید که لزوما مطلوب نیست و می‌خواهیم تغییر رنگ به آرامی و با انیمیشن رخ دهد. برای انجام این کار، کافیست تکه‌کد فوق را به شکل زیر، تغییر دهیم:

```
val backgroundColor by animateColorAsState(if (tabPage == TabPage.Home) Purple100 else Green300)
```

تابع animateColorAsState سبب می‌شود که تغییر در state ها، سبب انجام action مشخص شده به شکل انیمیشن‌دار باشد و نه به شکل ناگهانی؛ گیف زیر نشان می‌دهد که قطعه‌کد بالا، چگونه انیمیشنی ایجاد می‌کند:

به شکل مشابه می‌توان روی تغییر state های دیگر اپلیکیشن نیز انیمیشن وضع کرد تا تجربه‌ی کاربری بهتری برای کاربران از انجام امور خود در اپ، حاصل شود.


منابع

وب‌سایت developer.android.com
وب‌سایت https://blog.mindorks.com/learn-kotlin-sealed-classes
وب‌سایت https://www.raywenderlich.com/15361077-jetpack-compose-tutorial-for-android-getting-started
وب‌سایت https://github.com/android/compose-samples/tree/master/JetNews
وب‌سایت https://medium.com/swlh/jetpack-compose-tutorials-4e3b0e0efd0b
وب‌سایت https://material.io/design/environment/surfaces.html#properties


</div>
